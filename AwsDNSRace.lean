/-
AWS DNS Race Condition Analysis in Lean 4

Based on the TLA+ specification:
https://github.com/muratdem/TLA-seminar/blob/main/AwsDNSrace/AwsDNSRace.tla

This models the race condition where multiple enactors might try to apply
or clean up DNS plans concurrently, leading to deleted plans being applied.
-/

/-- Configuration constants for the system -/
structure Constants where
  /-- Maximum number of concurrent enactors -/
  max_enactors : Nat
  /-- Cleanup threshold for old plans -/
  cleanup_threshold : Nat

/-- Enactor program counter states -/
inductive EnactorPC
| idle      -- Enactor is waiting for work
| received  -- Enactor received a plan but hasn't applied it
| cleanup   -- Enactor is cleaning up old plans

deriving instance DecidableEq for EnactorPC

/-- System state for AWS DNS Race -/
structure State (C : Constants) where
  /-- Currently active Route53 plan -/
  current_plan : Nat
  /-- Last plan generated by the Planner -/
  latest_plan : Nat
  /-- Set of all existing plans (not yet deleted) -/
  existing_plans : List Nat
  /-- Current state of each enactor -/
  enactor_pc : Nat → EnactorPC
  /-- Plan that each enactor is working on -/
  enactor_plan : Nat → Nat

/-- Initial system state -/
def init_state (C : Constants) : State C :=
  { current_plan := 0,
    latest_plan := 0,
    existing_plans := [0],
    enactor_pc := fun _ => EnactorPC.idle,
    enactor_plan := fun _ => 0 }

/-- Planner creates a new plan -/
def planner_step (C : Constants) (s : State C) : State C :=
  let new_plan := s.latest_plan + 1
  { s with
    latest_plan := new_plan,
    existing_plans := new_plan :: s.existing_plans }

/-- Enactor receives a plan from the planner -/
def enactor_receive_step (C : Constants) (s : State C) (enactor : Nat) : State C :=
  if s.enactor_pc enactor = EnactorPC.idle then
    { s with
      enactor_pc := fun e => if e = enactor then EnactorPC.received else s.enactor_pc e,
      enactor_plan := fun e => if e = enactor then s.latest_plan else s.enactor_plan e }
  else s

/-- Enactor applies a plan (makes it current) -/
def enactor_apply_step (C : Constants) (s : State C) (enactor : Nat) : State C :=
  if s.enactor_pc enactor = EnactorPC.received ∧
     s.enactor_plan enactor ∈ s.existing_plans then
    { s with
      current_plan := s.enactor_plan enactor,
      enactor_pc := fun e => if e = enactor then EnactorPC.cleanup else s.enactor_pc e }
  else s

/-- Enactor cleans up old plans -/
def enactor_cleanup_step (C : Constants) (s : State C) (enactor : Nat) : State C :=
  if s.enactor_pc enactor = EnactorPC.cleanup then
    let my_plan := s.enactor_plan enactor
    let old_plans := s.existing_plans.filter (fun p =>
      p ≠ my_plan ∧ p < my_plan ∧ (my_plan - p) ≥ C.cleanup_threshold)
    { s with
      existing_plans := s.existing_plans.filter (fun p => p ∉ old_plans),
      enactor_pc := fun e => if e = enactor then EnactorPC.idle else s.enactor_pc e }
  else s

/-- Transition relation: one step of the system -/
def next_step (C : Constants) (s : State C) : List (State C) :=
  let planner_next := [planner_step C s]
  let enactor_receive_next := List.range C.max_enactors |>.map (enactor_receive_step C s)
  let enactor_apply_next := List.range C.max_enactors |>.map (enactor_apply_step C s)
  let enactor_cleanup_next := List.range C.max_enactors |>.map (enactor_cleanup_step C s)
  planner_next ++ enactor_receive_next ++ enactor_apply_next ++ enactor_cleanup_next

/-- System specification: starting from init, following transition relation -/
def system_spec (C : Constants) : Prop :=
  ∃ (trace : Nat → State C), trace 0 = init_state C ∧
  ∀ n, trace (n + 1) ∈ next_step C (trace n)

/-- Safety property: never delete the currently active plan -/
def never_delete_active {C : Constants} (s : State C) : Prop :=
  s.current_plan ∈ s.existing_plans

/-- Reachability relation via multiple steps -/
def reachable (C : Constants) : State C → State C → Prop :=
  fun s₁ s₂ => ∃ (trace : Nat → State C) (n : Nat),
    trace 0 = s₁ ∧ trace n = s₂ ∧
    ∀ k < n, trace (k + 1) ∈ next_step C (trace k)

/-- Race condition: a plan gets deleted while being applied -/
def has_race_condition {C : Constants} (s : State C) : Prop :=
  ∃ enactor : Nat,
    s.enactor_pc enactor = EnactorPC.received ∧
    s.enactor_plan enactor ∉ s.existing_plans

/-- Example configuration -/
def example_config : Constants :=
  { max_enactors := 2, cleanup_threshold := 1 }

/-- Verification examples -/
example : never_delete_active (init_state example_config) := by
  simp [never_delete_active, init_state]

example : ¬ has_race_condition (init_state example_config) := by
  simp [has_race_condition, init_state]

#check system_spec
#check never_delete_active
#check reachable
#check has_race_condition

/-- Example scenario demonstrating the race condition -/
def race_scenario : List String := [
  "Initial state: No active plans",
  "Step 1: Planner creates Plan 1",
  "Step 2: Enactor 1 receives Plan 1",
  "Step 3: Planner creates Plan 2",
  "Step 4: Enactor 2 receives Plan 2",
  "Step 5: Enactor 2 applies Plan 2 (becomes current)",
  "Step 6: Enactor 2 cleans up old plans (deletes Plan 1)",
  "Step 7: Enactor 1 tries to apply Plan 1 (already deleted!)",
  "Result: Race condition occurred - Plan 1 was deleted while Enactor 1 was processing it"
]

#eval race_scenario
