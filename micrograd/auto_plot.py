import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
import os
import subprocess

def run_lean_data_generator():
    """Run the Lean data generator to create CSV files"""
    print("Generating data with Lean...")
    try:
        result = subprocess.run(['lean', 'DataGenerator.lean'], 
                              capture_output=True, text=True, check=True)
        print("âœ“ Lean data generation completed")
        if result.stdout.strip():
            print("Lean output:", result.stdout.strip())
    except subprocess.CalledProcessError as e:
        print(f"Error running Lean: {e}")
        print(f"Stderr: {e.stderr}")
        return False
    except FileNotFoundError:
        print("Error: 'lean' command not found. Please make sure Lean is installed and in PATH")
        return False
    return True

def load_data():
    """Load data from CSV files generated by Lean"""
    try:
        # Load function metadata
        metadata = {}
        if os.path.exists('function_metadata.csv'):
            with open('function_metadata.csv', 'r') as f:
                for line in f:
                    if ',' in line:
                        key, value = line.strip().split(',', 1)
                        metadata[key] = value
            print(f"âœ“ Loaded function metadata: {metadata.get('function_name', 'f')}(x) = {metadata.get('function_expr', 'unknown')}")
        
        # Load main plot data
        if os.path.exists('plot_data.csv'):
            plot_data = pd.read_csv('plot_data.csv')
            print(f"âœ“ Loaded {len(plot_data)} plot points")
        else:
            print("Warning: plot_data.csv not found, using fallback data")
            x = np.linspace(-2, 4, 50)
            plot_data = pd.DataFrame({'x': x, 'y': 3*x**2 - 4*x + 5})
            metadata = {'function_name': 'f', 'function_expr': '3xÂ² - 4x + 5'}
        
        # Load special points
        if os.path.exists('special_points.csv'):
            special_data = pd.read_csv('special_points.csv')
            print(f"âœ“ Loaded {len(special_data)} special points")
        else:
            print("Warning: special_points.csv not found, using fallback points")
            special_data = pd.DataFrame({'x': [0, 1, 3], 'y': [5, 4, 20]})
        
        return plot_data, special_data, metadata
    except Exception as e:
        print(f"Error loading data: {e}")
        return None, None, {}

def create_plot(plot_data, special_data, metadata=None):
    """Create and display the plot"""
    if metadata is None:
        metadata = {}
    
    func_name = metadata.get('function_name', 'f')
    func_expr = metadata.get('function_expr', 'unknown function')
    
    plt.figure(figsize=(12, 8))
    
    # Main function curve
    plt.plot(plot_data['x'], plot_data['y'], 'b-', linewidth=2.5, 
             label=f'{func_name}(x) = {func_expr}', alpha=0.8)
    
    # Special evaluated points (only if they exist)
    if len(special_data) > 0:
        plt.scatter(special_data['x'], special_data['y'], 
                   color='red', s=80, zorder=5, 
                   label='Evaluated in Lean', edgecolors='darkred', linewidth=1.5)
    
    # Try to find and mark critical points for common function types
    try:
        # For quadratic functions, find vertex
        if 'xÂ²' in func_expr or 'x^2' in func_expr:
            # Try to extract coefficients for axÂ² + bx + c form
            x_vals = plot_data['x'].values
            y_vals = plot_data['y'].values
            
            # Find minimum/maximum point
            if len(y_vals) > 0:
                min_idx = np.argmin(y_vals)
                max_idx = np.argmax(y_vals)
                
                # Use minimum for upward parabolas, maximum for downward
                critical_idx = min_idx if y_vals[min_idx] < y_vals[max_idx] else max_idx
                critical_x = x_vals[critical_idx]
                critical_y = y_vals[critical_idx]
                
                critical_type = "Minimum" if critical_idx == min_idx else "Maximum"
                plt.scatter([critical_x], [critical_y], color='green', s=120, marker='*', 
                           zorder=5, label=f'{critical_type} ({critical_x:.3f}, {critical_y:.3f})',
                           edgecolors='darkgreen', linewidth=1.5)
    except Exception:
        pass  # Skip critical point detection if it fails
    
    # Styling
    plt.grid(True, alpha=0.3, linestyle='--')
    plt.xlabel('x', fontsize=12, fontweight='bold')
    plt.ylabel(f'{func_name}(x)', fontsize=12, fontweight='bold')
    plt.title(f'Function Plot Generated from Lean Data\n{func_name}(x) = {func_expr}', 
              fontsize=14, fontweight='bold', pad=20)
    
    # Annotations for special points
    for _, row in special_data.iterrows():
        plt.annotate(f'({row["x"]}, {row["y"]})', 
                    xy=(row['x'], row['y']), 
                    xytext=(10, 10), 
                    textcoords='offset points',
                    fontsize=10,
                    bbox=dict(boxstyle='round,pad=0.4', facecolor='yellow', 
                             alpha=0.8, edgecolor='orange'),
                    arrowprops=dict(arrowstyle='->', color='gray', alpha=0.7))
    
    plt.legend(fontsize=11, loc='best')
    plt.tight_layout()
    
    # Add some statistics
    print("\nğŸ“Š Function Analysis:")
    print(f"   Function: {func_name}(x) = {func_expr}")
    print(f"   Range plotted: x âˆˆ [{plot_data['x'].min():.1f}, {plot_data['x'].max():.1f}]")
    print(f"   Function range: y âˆˆ [{plot_data['y'].min():.3f}, {plot_data['y'].max():.3f}]")
    if len(special_data) > 0:
        print("   Special points evaluated:")
        for _, row in special_data.iterrows():
            print(f"     {func_name}({row['x']}) = {row['y']}")
    
    plt.show()

def main():
    """Main workflow: Generate data in Lean, then plot in Python"""
    print("ğŸš€ Automated Lean â†’ Python Plotting Workflow")
    print("=" * 50)
    
    # Step 1: Generate data with Lean
    if not run_lean_data_generator():
        print("âŒ Failed to generate data with Lean, exiting...")
        return
    
    # Step 2: Load the generated data
    plot_data, special_data, metadata = load_data()
    if plot_data is None or special_data is None:
        print("âŒ Failed to load data, exiting...")
        return
    
    # Step 3: Create and display the plot
    print("\nğŸ“ˆ Creating plot...")
    create_plot(plot_data, special_data, metadata)
    
    print("\nâœ… Workflow completed successfully!")
    print("\nğŸ’¡ To modify the function:")
    print("   1. Edit the function 'f' in DataGenerator.lean")
    print("   2. Run this script again: python auto_plot.py")

if __name__ == "__main__":
    main()